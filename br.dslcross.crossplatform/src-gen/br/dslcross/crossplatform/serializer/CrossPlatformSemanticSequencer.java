/*
 * generated by Xtext 2.24.0
 */
package br.dslcross.crossplatform.serializer;

import br.dslcross.crossplatform.crossPlatform.AbrevCmd;
import br.dslcross.crossplatform.crossPlatform.AssignmentCmdFor;
import br.dslcross.crossplatform.crossPlatform.AttribID;
import br.dslcross.crossplatform.crossPlatform.Attribute;
import br.dslcross.crossplatform.crossPlatform.AttributeCall;
import br.dslcross.crossplatform.crossPlatform.CallAttributeObject;
import br.dslcross.crossplatform.crossPlatform.ComLog;
import br.dslcross.crossplatform.crossPlatform.CrossPlatformPackage;
import br.dslcross.crossplatform.crossPlatform.DSLConcreteTypeRef;
import br.dslcross.crossplatform.crossPlatform.DSLGenericType;
import br.dslcross.crossplatform.crossPlatform.DSLGenericTypeRef;
import br.dslcross.crossplatform.crossPlatform.DataType;
import br.dslcross.crossplatform.crossPlatform.Deploy;
import br.dslcross.crossplatform.crossPlatform.Domainmodel;
import br.dslcross.crossplatform.crossPlatform.Entity;
import br.dslcross.crossplatform.crossPlatform.EntityEsp;
import br.dslcross.crossplatform.crossPlatform.EntityGlobCall;
import br.dslcross.crossplatform.crossPlatform.EntityGlobal;
import br.dslcross.crossplatform.crossPlatform.ExprArit;
import br.dslcross.crossplatform.crossPlatform.ExprL;
import br.dslcross.crossplatform.crossPlatform.ExprLogicFor;
import br.dslcross.crossplatform.crossPlatform.ExprLogica;
import br.dslcross.crossplatform.crossPlatform.Fator;
import br.dslcross.crossplatform.crossPlatform.FatorLogico;
import br.dslcross.crossplatform.crossPlatform.Global;
import br.dslcross.crossplatform.crossPlatform.GlobalEntity;
import br.dslcross.crossplatform.crossPlatform.GlobalOld;
import br.dslcross.crossplatform.crossPlatform.Import;
import br.dslcross.crossplatform.crossPlatform.MethodCallCmd;
import br.dslcross.crossplatform.crossPlatform.MethodCallGlob;
import br.dslcross.crossplatform.crossPlatform.MethodCallGlobal;
import br.dslcross.crossplatform.crossPlatform.MethodCallOp;
import br.dslcross.crossplatform.crossPlatform.OpElse;
import br.dslcross.crossplatform.crossPlatform.OpElseIf;
import br.dslcross.crossplatform.crossPlatform.OpLogico;
import br.dslcross.crossplatform.crossPlatform.OpLogicoDoWhile;
import br.dslcross.crossplatform.crossPlatform.OpLogicoFor;
import br.dslcross.crossplatform.crossPlatform.OpLogicoIF;
import br.dslcross.crossplatform.crossPlatform.OpLogicoWhile;
import br.dslcross.crossplatform.crossPlatform.Operation;
import br.dslcross.crossplatform.crossPlatform.OperationGlobCall;
import br.dslcross.crossplatform.crossPlatform.OperationGlobCallOld;
import br.dslcross.crossplatform.crossPlatform.OperationGlobal;
import br.dslcross.crossplatform.crossPlatform.OperationGlobalOld;
import br.dslcross.crossplatform.crossPlatform.PackageDeclaration;
import br.dslcross.crossplatform.crossPlatform.ParamList;
import br.dslcross.crossplatform.crossPlatform.Platform;
import br.dslcross.crossplatform.crossPlatform.PlatformDecl;
import br.dslcross.crossplatform.crossPlatform.SpecialCommand;
import br.dslcross.crossplatform.crossPlatform.StringTemplateFreeCod;
import br.dslcross.crossplatform.crossPlatform.Termo;
import br.dslcross.crossplatform.crossPlatform.TermoLogico;
import br.dslcross.crossplatform.crossPlatform.Vector;
import br.dslcross.crossplatform.services.CrossPlatformGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CrossPlatformSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CrossPlatformGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CrossPlatformPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CrossPlatformPackage.ABREV_CMD:
				sequence_AbrevCmd(context, (AbrevCmd) semanticObject); 
				return; 
			case CrossPlatformPackage.ASSIGNMENT_CMD_FOR:
				sequence_AssignmentCmdFor(context, (AssignmentCmdFor) semanticObject); 
				return; 
			case CrossPlatformPackage.ATTRIB_ID:
				sequence_AttribID(context, (AttribID) semanticObject); 
				return; 
			case CrossPlatformPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case CrossPlatformPackage.ATTRIBUTE_CALL:
				sequence_AttributeCall(context, (AttributeCall) semanticObject); 
				return; 
			case CrossPlatformPackage.CALL_ATTRIBUTE_OBJECT:
				sequence_CallAttributeObject(context, (CallAttributeObject) semanticObject); 
				return; 
			case CrossPlatformPackage.COM_LOG:
				sequence_ComLog(context, (ComLog) semanticObject); 
				return; 
			case CrossPlatformPackage.DSL_CONCRETE_TYPE_REF:
				sequence_DSLConcreteTypeRef(context, (DSLConcreteTypeRef) semanticObject); 
				return; 
			case CrossPlatformPackage.DSL_GENERIC_TYPE:
				sequence_DSLGenericType(context, (DSLGenericType) semanticObject); 
				return; 
			case CrossPlatformPackage.DSL_GENERIC_TYPE_REF:
				sequence_DSLGenericTypeRef(context, (DSLGenericTypeRef) semanticObject); 
				return; 
			case CrossPlatformPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case CrossPlatformPackage.DEPLOY:
				sequence_Deploy(context, (Deploy) semanticObject); 
				return; 
			case CrossPlatformPackage.DOMAINMODEL:
				sequence_Domainmodel(context, (Domainmodel) semanticObject); 
				return; 
			case CrossPlatformPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case CrossPlatformPackage.ENTITY_ESP:
				sequence_EntityEsp(context, (EntityEsp) semanticObject); 
				return; 
			case CrossPlatformPackage.ENTITY_GLOB_CALL:
				sequence_EntityGlobCall(context, (EntityGlobCall) semanticObject); 
				return; 
			case CrossPlatformPackage.ENTITY_GLOBAL:
				sequence_EntityGlobal(context, (EntityGlobal) semanticObject); 
				return; 
			case CrossPlatformPackage.EXPR_ARIT:
				sequence_ExprArit(context, (ExprArit) semanticObject); 
				return; 
			case CrossPlatformPackage.EXPR_L:
				sequence_ExprL(context, (ExprL) semanticObject); 
				return; 
			case CrossPlatformPackage.EXPR_LOGIC_FOR:
				sequence_ExprLogicFor(context, (ExprLogicFor) semanticObject); 
				return; 
			case CrossPlatformPackage.EXPR_LOGICA:
				sequence_ExprLogica(context, (ExprLogica) semanticObject); 
				return; 
			case CrossPlatformPackage.FATOR:
				sequence_Fator(context, (Fator) semanticObject); 
				return; 
			case CrossPlatformPackage.FATOR_LOGICO:
				sequence_FatorLogico(context, (FatorLogico) semanticObject); 
				return; 
			case CrossPlatformPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case CrossPlatformPackage.GLOBAL_ENTITY:
				sequence_GlobalEntity(context, (GlobalEntity) semanticObject); 
				return; 
			case CrossPlatformPackage.GLOBAL_OLD:
				sequence_GlobalOld(context, (GlobalOld) semanticObject); 
				return; 
			case CrossPlatformPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case CrossPlatformPackage.METHOD_CALL_CMD:
				sequence_MethodCallCmd(context, (MethodCallCmd) semanticObject); 
				return; 
			case CrossPlatformPackage.METHOD_CALL_GLOB:
				sequence_MethodCallGlob(context, (MethodCallGlob) semanticObject); 
				return; 
			case CrossPlatformPackage.METHOD_CALL_GLOBAL:
				sequence_MethodCallGlobal(context, (MethodCallGlobal) semanticObject); 
				return; 
			case CrossPlatformPackage.METHOD_CALL_OP:
				sequence_MethodCallOp(context, (MethodCallOp) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_ELSE:
				sequence_OpElse(context, (OpElse) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_ELSE_IF:
				sequence_OpElseIf(context, (OpElseIf) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_LOGICO:
				sequence_OpLogico(context, (OpLogico) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_LOGICO_DO_WHILE:
				sequence_OpLogicoDoWhile(context, (OpLogicoDoWhile) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_LOGICO_FOR:
				sequence_OpLogicoFor(context, (OpLogicoFor) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_LOGICO_IF:
				sequence_OpLogicoIF(context, (OpLogicoIF) semanticObject); 
				return; 
			case CrossPlatformPackage.OP_LOGICO_WHILE:
				sequence_OpLogicoWhile(context, (OpLogicoWhile) semanticObject); 
				return; 
			case CrossPlatformPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case CrossPlatformPackage.OPERATION_GLOB_CALL:
				sequence_OperationGlobCall(context, (OperationGlobCall) semanticObject); 
				return; 
			case CrossPlatformPackage.OPERATION_GLOB_CALL_OLD:
				sequence_OperationGlobCallOld(context, (OperationGlobCallOld) semanticObject); 
				return; 
			case CrossPlatformPackage.OPERATION_GLOBAL:
				sequence_OperationGlobal(context, (OperationGlobal) semanticObject); 
				return; 
			case CrossPlatformPackage.OPERATION_GLOBAL_OLD:
				sequence_OperationGlobalOld(context, (OperationGlobalOld) semanticObject); 
				return; 
			case CrossPlatformPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case CrossPlatformPackage.PARAM_LIST:
				sequence_ParamList(context, (ParamList) semanticObject); 
				return; 
			case CrossPlatformPackage.PARAMETER:
				sequence_Parameter(context, (br.dslcross.crossplatform.crossPlatform.Parameter) semanticObject); 
				return; 
			case CrossPlatformPackage.PLATFORM:
				sequence_Platform(context, (Platform) semanticObject); 
				return; 
			case CrossPlatformPackage.PLATFORM_DECL:
				sequence_PlatformDecl(context, (PlatformDecl) semanticObject); 
				return; 
			case CrossPlatformPackage.SPECIAL_COMMAND:
				sequence_SpecialCommand(context, (SpecialCommand) semanticObject); 
				return; 
			case CrossPlatformPackage.STRING_TEMPLATE_FREE_COD:
				sequence_StringTemplateFreeCod(context, (StringTemplateFreeCod) semanticObject); 
				return; 
			case CrossPlatformPackage.TERMO:
				sequence_Termo(context, (Termo) semanticObject); 
				return; 
			case CrossPlatformPackage.TERMO_LOGICO:
				sequence_TermoLogico(context, (TermoLogico) semanticObject); 
				return; 
			case CrossPlatformPackage.VECTOR:
				sequence_Vector(context, (Vector) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CommandOperation returns AbrevCmd
	 *     AbrevCmd returns AbrevCmd
	 *
	 * Constraint:
	 *     ((expr1=[Attribute|ID] (OpIn='++' | OpIn='--')) | (expr2=[Attribute|ID] (OpIn='+=' | OpIn='-=') expr3=ExprArit))
	 */
	protected void sequence_AbrevCmd(ISerializationContext context, AbrevCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns AssignmentCmdFor
	 *     AbrevCmd returns AssignmentCmdFor
	 *     AssignmentCmdFor returns AssignmentCmdFor
	 *
	 * Constraint:
	 *     (left=[Attribute|ID] e=ExprArit)
	 */
	protected void sequence_AssignmentCmdFor(ISerializationContext context, AssignmentCmdFor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.ASSIGNMENT_CMD_FOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.ASSIGNMENT_CMD_FOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.ASSIGNMENT_CMD_FOR__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.ASSIGNMENT_CMD_FOR__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentCmdForAccess().getLeftAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(CrossPlatformPackage.Literals.ASSIGNMENT_CMD_FOR__LEFT, false));
		feeder.accept(grammarAccess.getAssignmentCmdForAccess().getEExprAritParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttribID returns AttribID
	 *
	 * Constraint:
	 *     (name=ID v=Vector)
	 */
	protected void sequence_AttribID(ISerializationContext context, AttribID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.ATTRIB_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.ATTRIB_ID__NAME));
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.ATTRIB_ID__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.ATTRIB_ID__V));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttribIDAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttribIDAccess().getVVectorParserRuleCall_1_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeCall returns AttributeCall
	 *
	 * Constraint:
	 *     (name=ID col1='['? array=INT? col2=']'? (vAtr2+=AttribID (col+='(' value+=ExprL)?)*)
	 */
	protected void sequence_AttributeCall(ISerializationContext context, AttributeCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns Attribute
	 *     CommandPlat returns Attribute
	 *     Attribute returns Attribute
	 *     CommandOperation returns Attribute
	 *
	 * Constraint:
	 *     (many?='many'? name=ID type=[Type|ID] arrayAllow=INT? (concreteTypes+=[Type|ID] concreteTypes+=[Type|ID]?)?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns CallAttributeObject
	 *     CommandOperation returns CallAttributeObject
	 *     CallAttributeObject returns CallAttributeObject
	 *
	 * Constraint:
	 *     (obj=AttribID call+=AttribID* e=ExprArit)
	 */
	protected void sequence_CallAttributeObject(ISerializationContext context, CallAttributeObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComLog returns ComLog
	 *
	 * Constraint:
	 *     comLog='While'
	 */
	protected void sequence_ComLog(ISerializationContext context, ComLog semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.COM_LOG__COM_LOG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.COM_LOG__COM_LOG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComLogAccess().getComLogWhileKeyword_1_0(), semanticObject.getComLog());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLTypeRef returns DSLConcreteTypeRef
	 *     DSLConcreteTypeRef returns DSLConcreteTypeRef
	 *
	 * Constraint:
	 *     ref=[Type|ID]
	 */
	protected void sequence_DSLConcreteTypeRef(ISerializationContext context, DSLConcreteTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.DSL_CONCRETE_TYPE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.DSL_CONCRETE_TYPE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLConcreteTypeRefAccess().getRefTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(CrossPlatformPackage.Literals.DSL_CONCRETE_TYPE_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLTypeRef returns DSLGenericTypeRef
	 *     DSLGenericTypeRef returns DSLGenericTypeRef
	 *
	 * Constraint:
	 *     ref=[DSLGenericType|ID]
	 */
	protected void sequence_DSLGenericTypeRef(ISerializationContext context, DSLGenericTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.DSL_GENERIC_TYPE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.DSL_GENERIC_TYPE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLGenericTypeRefAccess().getRefDSLGenericTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CrossPlatformPackage.Literals.DSL_GENERIC_TYPE_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLGenericType returns DSLGenericType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLGenericType(ISerializationContext context, DSLGenericType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.DSL_GENERIC_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.DSL_GENERIC_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLGenericTypeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns DataType
	 *     Type returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (name=ID array=INT? (genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)?)
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Deploy
	 *     Type returns Deploy
	 *     Deploy returns Deploy
	 *
	 * Constraint:
	 *     (name=ID entityToDeploy+=Platform*)
	 */
	protected void sequence_Deploy(ISerializationContext context, Deploy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domainmodel returns Domainmodel
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 */
	protected void sequence_Domainmodel(ISerializationContext context, Domainmodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityEsp returns EntityEsp
	 *
	 * Constraint:
	 *     EspEnt+=[Entity|ID]
	 */
	protected void sequence_EntityEsp(ISerializationContext context, EntityEsp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns EntityGlobCall
	 *     EntityGlobCall returns EntityGlobCall
	 *     CommandOperation returns EntityGlobCall
	 *
	 * Constraint:
	 *     ((concreteTypes+=[Type|ID] concreteTypes+=[Type|ID]*)? opGlobCall=[GlobalEntity|ID])
	 */
	protected void sequence_EntityGlobCall(ISerializationContext context, EntityGlobCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandPlat returns EntityGlobal
	 *     EntityGlobal returns EntityGlobal
	 *
	 * Constraint:
	 *     ((genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)? opGlobal=[GlobalEntity|ID] cmdList+=CommandOperation*)
	 */
	protected void sequence_EntityGlobal(ISerializationContext context, EntityGlobal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Entity
	 *     Type returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID superType=[Entity|ID]? features+=CommandFeature*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprArit returns ExprArit
	 *
	 * Constraint:
	 *     (termos+=Termo ((op+='+' | op+='-') termos+=Termo)*)
	 */
	protected void sequence_ExprArit(ISerializationContext context, ExprArit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprL returns ExprL
	 *
	 * Constraint:
	 *     (
	 *         (v=ID col1='['? array=INT? col2=']'?) | 
	 *         (i=INT iD=INT?) | 
	 *         (vAtr1=ID vAtr2+=AttribID+) | 
	 *         strVar=STRING | 
	 *         opLog='true' | 
	 *         opLog='false'
	 *     )
	 */
	protected void sequence_ExprL(ISerializationContext context, ExprL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprLogicFor returns ExprLogicFor
	 *
	 * Constraint:
	 *     (
	 *         (inicio=AssignmentCmdFor condicao=ExprLogica abrevCmd=CommandOperation) | 
	 *         (inicio=AssignmentCmdFor condicao=ExprLogica abrevCmd=CommandOperation)
	 *     )
	 */
	protected void sequence_ExprLogicFor(ISerializationContext context, ExprLogicFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprLogica returns ExprLogica
	 *
	 * Constraint:
	 *     (termos+=TermoLogico (oplog+='||' termos+=TermoLogico)*)
	 */
	protected void sequence_ExprLogica(ISerializationContext context, ExprLogica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FatorLogico returns FatorLogico
	 *
	 * Constraint:
	 *     (
	 *         (n='!'? v=[Attribute|ID]) | 
	 *         (n='!'? op1='true') | 
	 *         (n='!'? op2='false') | 
	 *         exprLog=ExprLogica | 
	 *         (
	 *             n='!'? 
	 *             expr1=ExprL 
	 *             (
	 *                 OpRel='>' | 
	 *                 OpRel='>=' | 
	 *                 OpRel='<' | 
	 *                 OpRel='<=' | 
	 *                 OpRel='==' | 
	 *                 OpRel='<>'
	 *             ) 
	 *             expr2=ExprL
	 *         )
	 *     )
	 */
	protected void sequence_FatorLogico(ISerializationContext context, FatorLogico semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fator returns Fator
	 *
	 * Constraint:
	 *     (
	 *         <unknown> 
	 *         (
	 *             p=Parameter | 
	 *             (v=ID col1='['? array=INT? array2=ID? col2=']'?) | 
	 *             d=DECIMAL | 
	 *             strVar=STRING | 
	 *             mcOperation=MethodCallOp | 
	 *             mcGlobal=MethodCallGlob | 
	 *             expr=ExprArit | 
	 *             (vAtr1=AttribID (vAtr2+=AttribID col+='('?)+)
	 *         )
	 *     )
	 */
	protected void sequence_Fator(ISerializationContext context, Fator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns GlobalEntity
	 *     Type returns GlobalEntity
	 *     GlobalEntity returns GlobalEntity
	 *
	 * Constraint:
	 *     ((genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)? name=ID)
	 */
	protected void sequence_GlobalEntity(ISerializationContext context, GlobalEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns GlobalOld
	 *     Type returns GlobalOld
	 *     GlobalOld returns GlobalOld
	 *
	 * Constraint:
	 *     (
	 *         (genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)? 
	 *         name=ID 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         type=DSLTypeRef 
	 *         genericTypesDecl=DSLGenericType? 
	 *         col1='['? 
	 *         array=INT? 
	 *         col2=']'?
	 *     )
	 */
	protected void sequence_GlobalOld(ISerializationContext context, GlobalOld semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Global
	 *     Type returns Global
	 *     Global returns Global
	 *
	 * Constraint:
	 *     (
	 *         (genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)? 
	 *         name=ID 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         type=DSLTypeRef 
	 *         genericTypesDecl=DSLGenericType?
	 *     )
	 */
	protected void sequence_Global(ISerializationContext context, Global semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns MethodCallCmd
	 *     MethodCallCmd returns MethodCallCmd
	 *
	 * Constraint:
	 *     (obj=ID (call+=ID (args+=AttributeCall args+=AttributeCall*)*)+)
	 */
	protected void sequence_MethodCallCmd(ISerializationContext context, MethodCallCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodCallGlob returns MethodCallGlob
	 *
	 * Constraint:
	 *     (obj=[Attribute|ID]? calledOpGlobal=[Global|ID] (args+=AttributeCall args+=AttributeCall*)?)
	 */
	protected void sequence_MethodCallGlob(ISerializationContext context, MethodCallGlob semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns MethodCallGlobal
	 *     MethodCallGlobal returns MethodCallGlobal
	 *
	 * Constraint:
	 *     (call1=MethodCallGlob | call2=MethodCallOp)
	 */
	protected void sequence_MethodCallGlobal(ISerializationContext context, MethodCallGlobal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodCallOp returns MethodCallOp
	 *
	 * Constraint:
	 *     (call=[Operation|ID] (args+=AttributeCall args+=AttributeCall*)?)
	 */
	protected void sequence_MethodCallOp(ISerializationContext context, MethodCallOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OpElseIf returns OpElseIf
	 *
	 * Constraint:
	 *     (expLog=ExprLogica cmdList+=CommandOperation*)
	 */
	protected void sequence_OpElseIf(ISerializationContext context, OpElseIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OpElse returns OpElse
	 *
	 * Constraint:
	 *     cmdList+=CommandOperation*
	 */
	protected void sequence_OpElse(ISerializationContext context, OpElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns OpLogicoDoWhile
	 *     OpLogicoDoWhile returns OpLogicoDoWhile
	 *
	 * Constraint:
	 *     (cmdList+=CommandOperation* e=ExprLogica)
	 */
	protected void sequence_OpLogicoDoWhile(ISerializationContext context, OpLogicoDoWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns OpLogicoFor
	 *     OpLogicoFor returns OpLogicoFor
	 *
	 * Constraint:
	 *     (exprLogic=ExprLogicFor cmdList+=CommandOperation*)
	 */
	protected void sequence_OpLogicoFor(ISerializationContext context, OpLogicoFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns OpLogicoIF
	 *     OpLogicoIF returns OpLogicoIF
	 *
	 * Constraint:
	 *     (e=ExprLogica cmdList+=CommandOperation* opElseIf+=OpElseIf* opElse+=OpElse?)
	 */
	protected void sequence_OpLogicoIF(ISerializationContext context, OpLogicoIF semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns OpLogicoWhile
	 *     OpLogicoWhile returns OpLogicoWhile
	 *
	 * Constraint:
	 *     (left=ComLog e=ExprLogica cmdList+=CommandOperation*)
	 */
	protected void sequence_OpLogicoWhile(ISerializationContext context, OpLogicoWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OpLogico returns OpLogico
	 *
	 * Constraint:
	 *     (op1='true' | op2='false')
	 */
	protected void sequence_OpLogico(ISerializationContext context, OpLogico semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns OperationGlobCallOld
	 *     OperationGlobCallOld returns OperationGlobCallOld
	 *
	 * Constraint:
	 *     (
	 *         (concreteTypes+=[Type|ID] concreteTypes+=[Type|ID]*)? 
	 *         opGlobCall=[GlobalOld|ID] 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         typeGlobal=DSLTypeRef 
	 *         genericTypesDecl=[Type|ID]? 
	 *         col1='['? 
	 *         array=INT? 
	 *         col2=']'?
	 *     )
	 */
	protected void sequence_OperationGlobCallOld(ISerializationContext context, OperationGlobCallOld semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns OperationGlobCall
	 *     OperationGlobCall returns OperationGlobCall
	 *
	 * Constraint:
	 *     (
	 *         (concreteTypes+=[Type|ID] concreteTypes+=[Type|ID]*)? 
	 *         (paramList+=ParamList paramList+=ParamList*)? 
	 *         opGlobCall=[Global|ID] 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         typeGlobal=DSLTypeRef? 
	 *         genericTypesDecl=[Type|ID]? 
	 *         col1='['? 
	 *         array=INT? 
	 *         col2=']'? 
	 *         cmdList+=CommandOperation*
	 *     )
	 */
	protected void sequence_OperationGlobCall(ISerializationContext context, OperationGlobCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandPlat returns OperationGlobalOld
	 *     OperationGlobalOld returns OperationGlobalOld
	 *
	 * Constraint:
	 *     (
	 *         (genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)? 
	 *         opGlobal=[GlobalOld|ID] 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         type=DSLTypeRef 
	 *         genericTypesDecl=DSLGenericType? 
	 *         col1='['? 
	 *         array=INT? 
	 *         col2=']'? 
	 *         cmdList+=CommandOperation*
	 *     )
	 */
	protected void sequence_OperationGlobalOld(ISerializationContext context, OperationGlobalOld semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandPlat returns OperationGlobal
	 *     OperationGlobal returns OperationGlobal
	 *
	 * Constraint:
	 *     (
	 *         (genericTypes+=DSLGenericType genericTypes+=DSLGenericType*)? 
	 *         (paramList+=ParamList paramList+=ParamList*)? 
	 *         opGlobal=[Global|ID] 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         type=DSLTypeRef 
	 *         genericTypesDecl=DSLGenericType? 
	 *         col1='['? 
	 *         array=INT? 
	 *         col2=']'? 
	 *         cmdList+=CommandOperation*
	 *     )
	 */
	protected void sequence_OperationGlobal(ISerializationContext context, OperationGlobal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns Operation
	 *     CommandPlat returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         paramExtra=ExprArit? 
	 *         name=ID 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         (type=DSLTypeRef (genericTypesDecl+=[Type|ID] genericTypesDecl+=[Type|ID]*)? col1='['? array=INT? col2=']'?)? 
	 *         cmdList+=CommandOperation*
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns PackageDeclaration
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=AbstractElement*)
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamList returns ParamList
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ParamList(ISerializationContext context, ParamList semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CrossPlatformPackage.Literals.PARAM_LIST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CrossPlatformPackage.Literals.PARAM_LIST__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamListAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=DSLTypeRef 
	 *         col1='['? 
	 *         array=INT? 
	 *         col2=']'? 
	 *         ref=[Type|ID]?
	 *     )
	 */
	protected void sequence_Parameter(ISerializationContext context, br.dslcross.crossplatform.crossPlatform.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns PlatformDecl
	 *     Type returns PlatformDecl
	 *     PlatformDecl returns PlatformDecl
	 *
	 * Constraint:
	 *     (name=ID (Base='Java' | Base='Swift' | Base='CPlusPlus' | Base='CSharp') cmdList+=CommandPlat*)
	 */
	protected void sequence_PlatformDecl(ISerializationContext context, PlatformDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Platform returns Platform
	 *
	 * Constraint:
	 *     (
	 *         ent=[Entity|ID] 
	 *         plat=[PlatformDecl|ID] 
	 *         ((Communication='Input' | Communication='Output' | Communication='InOut') EntityEspecification=EntityEsp?)?
	 *     )
	 */
	protected void sequence_Platform(ISerializationContext context, Platform semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandOperation returns SpecialCommand
	 *     SpecialCommand returns SpecialCommand
	 *
	 * Constraint:
	 *     (command='break' | attr=[Attribute|ID] | commandCont='continue')
	 */
	protected void sequence_SpecialCommand(ISerializationContext context, SpecialCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandFeature returns StringTemplateFreeCod
	 *     CommandOperation returns StringTemplateFreeCod
	 *     StringTemplateFreeCod returns StringTemplateFreeCod
	 *
	 * Constraint:
	 *     value+=STRINGTEMPLATE
	 */
	protected void sequence_StringTemplateFreeCod(ISerializationContext context, StringTemplateFreeCod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermoLogico returns TermoLogico
	 *
	 * Constraint:
	 *     (fatores+=FatorLogico (oplog+='&&' fatores+=FatorLogico)*)
	 */
	protected void sequence_TermoLogico(ISerializationContext context, TermoLogico semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Termo returns Termo
	 *
	 * Constraint:
	 *     (fatores+=Fator ((op+='*' | op+='/') fatores+=Fator)*)
	 */
	protected void sequence_Termo(ISerializationContext context, Termo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Vector returns Vector
	 *
	 * Constraint:
	 *     (col1='['? array=INT? col2=']'?)
	 */
	protected void sequence_Vector(ISerializationContext context, Vector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
