/**
 * generated by Xtext 2.13.0
 */
package br.dslcross.crossplatform.validation;

import br.dslcross.crossplatform.crossPlatform.CrossPlatformPackage;
import br.dslcross.crossplatform.crossPlatform.DSLConcreteTypeRef;
import br.dslcross.crossplatform.crossPlatform.DSLGenericType;
import br.dslcross.crossplatform.crossPlatform.DSLGenericTypeRef;
import br.dslcross.crossplatform.crossPlatform.DSLTypeRef;
import br.dslcross.crossplatform.crossPlatform.Global;
import br.dslcross.crossplatform.crossPlatform.MethodCallGlob;
import br.dslcross.crossplatform.crossPlatform.MethodCallOp;
import br.dslcross.crossplatform.crossPlatform.Operation;
import br.dslcross.crossplatform.crossPlatform.OperationGlobal;
import br.dslcross.crossplatform.crossPlatform.Parameter;
import br.dslcross.crossplatform.crossPlatform.Type;
import br.dslcross.crossplatform.validation.AbstractCrossPlatformValidator;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CrossPlatformValidator extends AbstractCrossPlatformValidator {
  @Check
  public void checkMethodCallOp(final MethodCallOp mOpCall) {
    final Operation mOp = mOpCall.getCall();
    int countConcret = 0;
    EList<Parameter> _params = mOp.getParams();
    for (final Parameter p : _params) {
      DSLTypeRef _type = p.getType();
      if ((_type instanceof DSLGenericTypeRef)) {
      } else {
        countConcret++;
      }
    }
    int _size = mOpCall.getArgs().size();
    boolean _notEquals = (_size != countConcret);
    if (_notEquals) {
      int _size_1 = mOpCall.getArgs().size();
      String _plus = ("Parameters don\'t match with local method. Size:  MethodCallOp " + Integer.valueOf(_size_1));
      String _plus_1 = (_plus + " Local ");
      String _plus_2 = (_plus_1 + Integer.valueOf(countConcret));
      this.error(_plus_2, CrossPlatformPackage.Literals.METHOD_CALL_OP__ARGS);
    }
  }
  
  @Check
  public void checkMethodCallGlobal(final MethodCallGlob mcCallGlob) {
    final Global mc = mcCallGlob.getCalledOpGlobal();
    int countConcret = 0;
    EList<Parameter> _params = mc.getParams();
    for (final Parameter p : _params) {
      DSLTypeRef _type = p.getType();
      if ((_type instanceof DSLGenericTypeRef)) {
        countConcret++;
      } else {
        countConcret++;
      }
    }
    int _size = mcCallGlob.getArgs().size();
    boolean _notEquals = (_size != countConcret);
    if (_notEquals) {
      int _size_1 = mcCallGlob.getArgs().size();
      String _plus = ("Parameters don\'t match with global method. Size:  MetCallGlob " + Integer.valueOf(_size_1));
      String _plus_1 = (_plus + 
        " Global ");
      String _plus_2 = (_plus_1 + Integer.valueOf(countConcret));
      this.error(_plus_2, CrossPlatformPackage.Literals.METHOD_CALL_GLOB__ARGS);
    }
  }
  
  /**
   * @Check
   * def checkGlobalUses(OperationGlobCall gmu) {
   * val gms = gmu.opGlobCall
   * 
   * //if (gmu.concreteTypes.size != gms.genericTypes.size) {
   * //	error('Concrete types don\'t match generic types',
   * //		CrossPlatformPackage.Literals.OPERATION_GLOB_CALL__CONCRETE_TYPES)
   * //}
   * 
   * val concreteTypesSize = gmu.concreteTypes.size;
   * val typeConcretizationMap = new HashMap<String, Type>()
   * 
   * for (var i = 0; i < concreteTypesSize; i++) {
   * val concreteTypeGmu = gmu.concreteTypes.get(i);
   * val genericTypeGms = gms.genericTypes.get(i);
   * typeConcretizationMap.put(genericTypeGms.name, concreteTypeGmu)
   * }
   * 
   * //if (gmu.params.size != gms.params.size) {
   * //	error('Parameters don\'t match', CrossPlatformPackage.Literals.OPERATION_GLOB_CALL__PARAMS)
   * //}
   * 
   * //if (!typeMatch(gmu.typeGlobal, gms.type, typeConcretizationMap)) {
   * //	error('Return type doesn\'t match', CrossPlatformPackage.Literals.OPERATION_GLOB_CALL__TYPE_GLOBAL)
   * //}
   * 
   * val paramsSize = gmu.params.size;
   * 
   * for (var i = 0; i < paramsSize; i++) {
   * val paramGmu = gmu.params.get(i);
   * val paramGms = gms.params.get(i);
   * if (!typeMatch(paramGmu.type, paramGms.type, typeConcretizationMap)) {
   * error('Parameter types don\'t match', CrossPlatformPackage.Literals.OPERATION_GLOB_CALL__PARAMS)
   * }
   * if (!paramGmu.name.equals(paramGms.name)) {
   * error('Parameter names don\'t match', CrossPlatformPackage.Literals.OPERATION_GLOB_CALL__PARAMS)
   * }
   * }
   * }
   */
  @Check
  public void checkGlobalImplements(final OperationGlobal gmi) {
    final Global gms = gmi.getOpGlobal();
    final int genericTypesSize = gmi.getGenericTypes().size();
    for (int i = 0; (i < genericTypesSize); i++) {
      {
        final DSLGenericType genericTypeGmu = gmi.getGenericTypes().get(i);
        final DSLGenericType genericTypeGms = gms.getGenericTypes().get(i);
        boolean _genericTypeMatch = this.genericTypeMatch(genericTypeGmu, genericTypeGms);
        boolean _not = (!_genericTypeMatch);
        if (_not) {
          this.error("Generic types don\'t match", CrossPlatformPackage.Literals.OPERATION_GLOBAL__GENERIC_TYPES);
        }
      }
    }
    int _size = gmi.getParams().size();
    int _size_1 = gms.getParams().size();
    boolean _lessThan = (_size < _size_1);
    if (_lessThan) {
      this.error("Parameters don\'t match", CrossPlatformPackage.Literals.OPERATION_GLOBAL__PARAMS);
    }
    int paramsSize = 0;
    final int paramsSizeGmi = gmi.getParams().size();
    final int paramsSizeGms = gms.getParams().size();
    if ((paramsSizeGmi <= paramsSizeGms)) {
      paramsSize = paramsSizeGmi;
    } else {
      paramsSize = paramsSizeGms;
    }
    for (int i = 0; (i < paramsSize); i++) {
      {
        final Parameter paramGmi = gmi.getParams().get(i);
        final Parameter paramGms = gms.getParams().get(i);
        boolean _typeMatch = this.typeMatch(paramGmi.getType(), paramGms.getType(), null);
        boolean _not = (!_typeMatch);
        if (_not) {
          this.error("Parameter types don\'t match", CrossPlatformPackage.Literals.OPERATION_GLOBAL__PARAMS);
        }
        boolean _equals = paramGmi.getName().equals(paramGms.getName());
        boolean _not_1 = (!_equals);
        if (_not_1) {
          this.error("Parameter names don\'t match", CrossPlatformPackage.Literals.OPERATION_GLOB_CALL__PARAMS);
        }
      }
    }
  }
  
  public boolean genericTypeMatch(final DSLGenericType genericType1, final DSLGenericType genericType2) {
    return genericType1.getName().equals(genericType2.getName());
  }
  
  public boolean typeMatch(final DSLTypeRef type1, final DSLTypeRef type2, final HashMap<String, Type> typeConcretizationMap) {
    if (((type1 instanceof DSLConcreteTypeRef) && (type2 instanceof DSLConcreteTypeRef))) {
      final DSLConcreteTypeRef ctr1 = ((DSLConcreteTypeRef) type1);
      final DSLConcreteTypeRef ctr2 = ((DSLConcreteTypeRef) type2);
      boolean _equals = ctr1.getRef().equals(ctr2.getRef());
      if (_equals) {
        return true;
      }
    }
    if (((type1 instanceof DSLGenericTypeRef) && (type2 instanceof DSLGenericTypeRef))) {
      final DSLGenericTypeRef gtr1 = ((DSLGenericTypeRef) type1);
      final DSLGenericTypeRef gtr2 = ((DSLGenericTypeRef) type2);
      boolean _equals_1 = gtr1.getRef().getName().equals(gtr2.getRef().getName());
      if (_equals_1) {
        return true;
      }
    }
    if ((((type1 instanceof DSLConcreteTypeRef) && (type2 instanceof DSLGenericTypeRef)) && 
      (typeConcretizationMap != null))) {
      final DSLConcreteTypeRef ctr1_1 = ((DSLConcreteTypeRef) type1);
      final DSLGenericTypeRef gtr2_1 = ((DSLGenericTypeRef) type2);
      final Type ctr2_1 = typeConcretizationMap.get(gtr2_1.getRef().getName());
      boolean _equals_2 = ctr1_1.getRef().equals(ctr2_1);
      if (_equals_2) {
        return true;
      }
    }
    return false;
  }
}
